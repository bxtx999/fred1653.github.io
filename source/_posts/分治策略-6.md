---
title: 分治策略-典型算法.md
updated: 2021-08-25 21:36:41
categories: "算法"
tags: ["算法与数据结构", "algorithms", "data structure", "分治策略"]
desc: 分治策略的典型算法
---

## 选择问题

### 选最大和最小

输入：集合$L$（含$n$个不等的实数）

输出：$L$中的第$i$小的元素

- $i=1$，称为最小元素

- $i=n$，称为最大元素

位置处在中间爱你位置的元素，成为**中位元素**。

$n$为奇数，中位数唯一，$i=(n+1)/2$。

$n$为偶数，可指定为$i=n/2+1$。

选最大算法：顺序比较，在最坏情况下的时间为$W(n)=n-1$。

<!-- more -->

代码为：

```python
def max_value(numbers: List[int]) -> Tuple[int, int]:
    if not numbers:
        return (-1, -1)
    if len(numbers) == 1:
        return (0, numbers[0])

    m = numbers[0], k = 0
    for i in range(1, len(numbers)):
        if m < numbers[i]:
            m = numbers[i]
            k = i
    return (k, m)
```

**选最大最小通常算法**：

- 比较算法，先选最大max

- 顺序比较，在剩余数组中选最小min，类似于选最大算法，但比较时保留最小值。

时间复杂度：$W(n)=n-1 + n-2 = 2n -3$

**分组算法解决最大最小值**：

输入：n个数的数组L

输出：max，min

1. 将n个元素两两一组分成$\lfloor n/2 \rfloor$组。

2. 每组比较，得到$\lfloor n/2 \rfloor$个较小和$\lfloor n/2 \rfloor$个较大的。

3. 在$\lceil n/2 \rceil$个较大（含轮空元素）找最大max

4. 在$\lceil n/2 \rceil$个比较（含轮空元素）中找最小min

时间复杂度：

- 在上述代码2中，组内比较$\lfloor n/2 \rfloor$次。

- 在3-4行内求max和min比较，最多$2 \times (\lceil n/2 \rceil - 1)$次。

- 即$W(n)=\lfloor n/2 \rfloor + 2 \times \lceil n/2 \rceil - 2 \\ = n + \lceil n/2 \rceil - 2 \\ = \lceil 3n/2 \rceil -2$

**分治算法**：

1. 将数组$L$从中间划分为2个子数组$L_1, L_2$

2. 递归地在$L_1$中求最大的$max_1$和$min_1$

3. 递归地在$L_2$中求最大的$max_2$和$min_2$

4. $max \gets \max{\{max_1, max_2\}}$

5. $min \gets \min {\{min_1, min_2\}}$

**代码**：

```python
import math
from typing import List, Tuple


def max_min(arr: List[int]) -> Tuple[int, int]:
    i, j = 0, len(arr) - 1
    if i == j:
        return [arr[i], arr[i]]
    elif i == j - 1:
        return [arr[i], arr[j]] if arr[i] > arr[j] else [arr[j], arr[i]]
    else:
        mid = math.floor(j/2)
        max1, min1 = max_min(arr[i : mid])
        max2, min2 = max_min(arr[mid : j + 1])
        return [max(max1, max2), min(min1, min2)]

if __name__ == "__main__":
    arr = [6, 10, 32, 8, 19, 20, 222, 14, 53, 1]
    max_value, min_value = max_min(arr)
    print(max_value, min_value)  # 222, 1
```

最坏情况复杂度：

假设$\quad n=2^k, \\ \quad\quad W(n) = 2W(n/2) + 2 \\ \quad\quad W(2)=1$

解

$$
W(2^k) = 2W(2^{k-1}) + 2 \\ = 2 [ 2W(2^{k-2}) + 2] +2 \\ = 2^2W(2^{k-2})+2^2+2=... \\ 2^{k-1} + 2^{k-1} + ... + 2^2 + 2 \\ = 3 \times 2^{k-1} -2 =3n/2-2
$$

**选择算法小结**：

- 选最大：顺序比较，比较次数$n-1$

- 选最大最小：

  - 选择最大+最小，比较次数$2n-3$
  
  - 分组：比较次数$\lceil 3n/2 \rceil -2$

  - 分治：$n=2^k$，比较次数$3n/2-2$

### 选第二大问题

### 一般选择算法的设计

### 选择算法的分析

## 信号平滑处理

### 卷积及其应用

### 卷积计算

### 快速傅里叶变换FFT算法

## 平面点集的凸包
