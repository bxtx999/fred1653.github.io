---
title: 多线程编程
date: 2021-08-16 14:50:08
tags: ["多线程"]
categories: ["OS", "Linux"]
desc: 多线程
toc: true
---

## 进程与线程

**进程**是资源（CPU、内存等）分配的基本单位，具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。
**线程**是进程的一个实体，是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

<!-- more -->

进程与线程的区别

- 进程是资源分配的基本单位；线程是程序执行的基本单位。
- 进程拥有自己的资源空间，没启动一个进程，系统就会为它分配地址空间；

- 线程与CPU资源分配无关，多个线程共享同一进程内的资源，使用相同的地址空间。

- 一个进程可以包含若干个线程。

线程与进程的优劣势：

- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（Inter Process Communication，IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
线程的调度与切换比进程快很多，同时创建一个线程的开销也比进程要小很多。
- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

进程的本质：正在执行的一个程序，可以进程比作一个容器或者工厂

- 进程与进程之间相对独立

- 进程可以包括几个或者上百个线程在运行。

- 内存（逻辑内存）包括在进程里面，每个进程的内存都是互相独立的，但从一个更高的层次上看，不同的进程也共享着一个巨大的空间，这个空间就是整个计算机。

- 进程共有文件/网络句柄（handle），这样可以打开同一个文件，抢同一个网络端口。

线程的本质：真正运行的是一个一个的线程

- 栈（堆栈）：主线程的main函数、进行函数调用的参数和返回地址、局部变量等内容都会被压入栈内

- PC（Program Couner）：程序计数器，PC的指针指向代码所在的内存地址。

- TLS（Thread local storage）：分配内存，存放变量

进程/线程如何通信?

进程可以通过管道、套接字、信号交互、共享内存、消息队列等等进行通信；而线程本身就会共享内存，指针指向同一个内容，交互很容易。

```text
进程process：进程就是时间总和=执行环境切换时间+程序执行时间-->CPU加载执行环境->CPU执行程序->CPU保存执行环境
线程thread：线程也是时间总和=执行环境切换时间（共享进程的）+程序模块执行时间-->CPU加载执行环境（共享进程的）->CPU执行程序摸块->CPU保存执行环境（共享进程的）
进程和线程都是一个时间段的描述，是CPU工作时间段的描述。是运行中的程序指令的一种描述，这需要与程序中的代码区别开来，线程是更细小的时间段。
```

## 线程安全的方法

线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

根据《Java Concurrency in Practice》的定义，一个线程安全的 class 应当满足以下三个条件：

- 多个线程同时访问时，其表现出正确的行为。

- 无论操作系统如何调度这些线程， 无论这些线程的执行顺序如何交织（interleaving）。

- 调用端代码无须额外的同步或其他协调动作。

另外一种定义，同一类型的多个对象能分别被各自所属的不同线程并发访问，就算是线程安全的。在这个定义下，C++ 标准库容器和基本类型都是“线程安全的”。为了与前一种定义区别，这个一般叫做 thread compatible。

1. 如何理解互斥锁、条件锁、读写锁以及自旋锁？

   - https://www.zhihu.com/question/66733477/answer/1267625567

   - https://www.zhihu.com/question/66733477/answer/246535792

   - 使用场景 https://zhuanlan.zhihu.com/p/246114725

2. 无锁编程的场景

   https://zhuanlan.zhihu.com/p/38664758

## 无锁的数据结构

为什么要无锁编程？

- 异步比同步要好

- 非阻塞比阻塞要好，而锁会引起阻塞，线程一直在跑就是正常的cpu调度，阻塞唤醒一次则意味着两次cpu调度，且竞争比较激烈的时候，一次唤醒所有等待锁的线程又会带来阻塞。
