---
title: 贪心算法基础
date: 2021-09-18 23:44:16
categories: "算法"
tags: ["算法与数据结构", "algorithms", "data structure", "贪心算法"]
desc: 贪心算法（greedy algorithm），又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。
toc: true
---

本文开始记录贪心算法的学习。

## 贪心算法的例子——活动选择问题

输入：$S=\{1,2,...,n\}$为$n$项活动的集合，$s_i$、$f_i$分别为活动$i$的开始和结束时间。

活动$i$ 与$j$相容 $\iff s_i \ge f_j$ 或 $s_j \ge f_i$

求：最大的两两相容的活动集$A$

<!-- more -->

输入实例：

| $i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $s_i$ | 1 | 3 | 2 | 5 | 4 | 5 | 6 | 8 | 8 | 2 |
| $f_i$ | 4 | 5 | 6 | 7 | 9 | 9 | 10 | 11 | 12 | 13 |

解：$\{1,4,8\}$

## 贪心算法

贪心算法（greedy algorithm）的挑选过程是多步判断，每步依据某种“短视”的策略进行选择，选择时注意满足条件相容性条件。

**策略1**：开始时间早的优先排序使$s_1\le s_2 \le ... \le s_n$，从前向后挑选；

**策略2**：占用时间少的优先排序使得$f_1-s_1 \le f_2 - s_2 \le ... \le f_n - s_n$，从前向后挑选。

**策略3**：结束早的优先排序使得$f_1 \le f_2 \le ... \le f_n$，从前向后挑选。

### 策略1的反例

策略1：开始早的优先

反例：$S=\{1,2,3\}$

$s_1=0,f_1=20,s_2=2,f_2=5,s_3=8,f_3=15$

![strategy 1](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/strategy_1_20210919.png)

### 策略2的反例

策略2：占时少的优先

反例：$S=\{1,2,3\}$

$s_1=0,f_1=8,s_2=7,f_2=9,s_3=8,f_3=15$

![strategy 2](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/strategy_2_20210919.png)

### 策略3伪码

算法：Greedy Select

输入：活动集$S, s_i, f_i, i=1,2,...,n, f_1 \le ... \le f_n$

输出：$A \subseteq S$，选中的活动子集

1. $n \gets length[S]$

2. $A \gets \{1\}$

3. $j \gets 1$

4. for $i \gets 2$ to $n$ do

5. $\quad \quad if \quad s_i \ge f_j$

6. $\quad \quad then \quad A \gets A \cup \{i\}$

7. $\quad \quad \quad \quad \quad j \gets i$

8. return A

完成事件 $t=\max \{f_k: k \in A\}$

### 运行实例

输入：$S=\{1,2,...,10\}$

| $i$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $s_i$ | $\fcolorbox{red}{aqua}{1}$ | 3 | 0 | $\fcolorbox{red}{aqua}{5}$ | 3 | 5 | 6 | $\fcolorbox{red}{aqua}{8}$ | 8 | 2 |
| $f_i$ | $\fcolorbox{red}{aqua}{4}$ | 5 | 6 | $\fcolorbox{red}{aqua}{7}$ | 8 | 9 | 10 | $\fcolorbox{red}{aqua}{11}$ | 12 | 13 |

解：$A=\{1,4,8\},\quad t=11$

时间复杂度：$O(n \log n) + O(n)=O(n\log n)$

## 贪心算法的特点

设计要素：

1. 贪心算法适用于组合优化问题；

2. 求解过程是多步判断过程，最终的判断序列对应于问题的最优解；

3. 依据某种“短视”的贪心选择性质判断，性质好坏决定算法的成败；

4. 贪心法必须进行正确性证明；

5. 证明贪心法不正确的技巧：举反例。

## 贪心算法的正确性证明

### 一个数学归纳法的例子

例：证明对于任何自然数$n$，$1+2+...+n=n(n+1)/2$

证 $n=1$，左边$=1$，右边$=1 \times (1+1)/2=1$

假设对任意自然数$n$等式成立，则

$\large 1+2+...+(n+1) \\ =(1+2+...+n)+(n+1) \\ =n(n+1)/2 + (n+1) \\ =(n+1)(n/2+1) \\ =(n+1)(n+2)/2$

### 第一数学归纳法

适合证明涉及自然数的命题$P(n)$

归纳基础：证明$P(1)$为真（或者$P(0)$为真）

归纳步骤：若对所有$n$有$P(n)$为真，证明$P(n+1)$为真

$$
\forall n, P(n) \to P(n+1) \\
\quad \quad \quad P(1) \\
n=1,\quad P(1) \implies P(2) \\
n=2,\quad P(2) \implies P(3) \\
\quad \quad \quad ...
$$

### 第二数学归纳法

适合证明涉及自然数的命题$P(n)$

归纳基础：证明$P(1)$为真（或$P(0)$为真）

归纳步骤：若对所有小于$n$的$k$有$P(k)$真，证明$P(n)$为真

$$
\forall k(k<n \land P(k)) \to P(n) \\
\quad \quad \quad P(1) \\
n=2, P(1) \implies P(2) \\
n=3, P(1) \land P(2) \implies P(3) \\
\quad \quad \quad ...
$$

### 两种归纳法的区别

归纳基础一样：$P(1)$为真

归纳步骤不同：

证明逻辑

![logic](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/20210919_logic.png)

### 算法正确性归纳证明

证明步骤：

1. 叙述一个有关自然数$n$的命题，该命题断定该贪心策略的执行最终将导致最优解。其中自然数$n$可以代表算法步数或问题规模。

2. 证明命题对所有的自然数为真。

   归纳基础（从最小实例规模开始）

   归纳步骤（第一或第二数学归纳法）

### 活动选择算法的命题

命题：

算法Select执行到第$k$步，选择$k$项活动

$\quad \quad i_1=1,i_2,...,i_k$

则存在最优解$A$包含活动$i_1=1,i_2,...,i_k$。

根据上述命题：对于任何$k$，算法前$k$步的选择都将导致最优解，至多到第$n$步将得到问题实例的最优解。

#### 归纳证明：归纳基础

令$S=\{1,2,...,n\}$是活动集，且$f_i\le ...\le f_n$。

归纳基础：$k=1$，证明存在最优解包含活动$1$

证：    任取最优解A，A中的活动按截止时间递增排列。如果$A$的第一个活动为$j,j \not 1$，用$1$替换$A$的活动j得到解$A'$，即

$\quad \quad \quad A' = (A-\{j\}) \cup \{1\}$，

由于$f_1 \le f_j$，$A'$也是最优解，且含有1。

#### 归纳步骤

假设命题对$k$为真，证明对$k+1$也为真

证明：算法执行到第k步，选择了活动$i_1=1,i_2,...,i_k$，根据归纳假设存在最优解A包含$i_1=1,i_2,...,i_k$，$A$中剩下活动选自集合$S'$

$$
S'=\{i|i \in S, s_i \ge f_k\} \\
A=\{i_1,i_2,...,i_k\} \cup B
$$

![](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/20210919_stage1.png)

$B$是$S'$的最优解。（若不然，$S'$的最优解为$B^*$，$B^*$的活动比B多，那么

$\quad \quad \quad B^* \cup \{1,i_2,...,i_k\}$

是$S$的最优解，且比$A$的活动多，与$A$的最优性矛盾。）

![](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/20210919_stage2.png)

将$S'$看成子问题，根据归纳基础，

存在$S'$的最优解$B'$有$S'$中的第一个活动$i_{k+1}$，且$|B'|=|B|$，于是

$\{i_1,i_2,...,i_k\} \cup B' \\ =\{i_1,i_2,...,i_k,i_{k+1}\} \cup (B'-\{i_{k+1}\})$

也是原问题的最优解。

![](https://cdn.jsdelivr.net/gh/jnhu76/Image-Hosting@master/img/20210919_stage3.png)

## 最优装载问题

问题：$n$个集装箱$1,2,...,n$装上轮船，集装箱$i$的重量$w_i$，轮船装载限制为$C$，无体积限制。问如何装使得上船的集装箱最多？不妨设每个箱子的重量$w_i\le C$。

## 最小延迟调度

## 得不到最优解的处理方法
