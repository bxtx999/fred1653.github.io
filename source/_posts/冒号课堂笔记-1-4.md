---
title: 冒号课堂笔记(1-4课)
categories: "编程"
date: 2020-05-17 16:16:44
tags: ["编程范式"]
---

### 《冒泡课堂：编程范式与OOP思想》读书笔记 1-4 课

##### 编程范式

1. 范式译自英文的paradigm，也有译作典范、范型、范例的。所谓编程范式（programming paradigm），指的是计算机编程的基本风格或典范模式。借用哲学术语，如果说每个编程者都在创造虚拟世界，那么编程范式就是他们置身其中自觉不自觉采用德尔世界观与方法论。

<!-- more -->

2. 库（lib）与框架（framework）
   
   + 为保证软件开发快速有效，通常采取：
     
     在宏观管理上选取框架以控制整体的结构与流程；在微观实现上利用库和工具包来解决细节问题。
   
   + 框架的意义在于使设计者在特定领域的整体设计上不必重新发明轮子；库和工具包的意义在于使开发者摆脱底层编码，专注于特定问题和业务逻辑。
   
   + 库和工具包是为给程序员带来自由的，框架是为程序员带来约束的。
   
   + 库和工具包侧重代码重用，框架侧重设计重用。
   
   + 框架是通过控制反转（IoC）机制控制全局，而库和工具包用callback知识局部的控制反转。程序员牺牲了对应用程序流程的主导权，换来的是更简洁的代码和更高的生产效率。

3. 设计模式是软件的战术思想，架构师软件的战略决策。与框架、库和工具包不同，他们不是软件产品，是软件思想。
   
   设计模式与惯用法都是针对常发问题的解决方法，但前者重设计，后者偏实现。

4. 控制反转（Inversion of Control）是一种软件设计原则，与朝哪个用的用户代码调用可重用库（library）代码不同，IoC倒转控制流方向：由库代码调用用户代码。有人将此比作好莱坞原则：”不要打电话给我们，我们会打给你的”。

5. 命令式编程时冯·诺依曼机运行机制的抽象。它把程序看作由若干行动指令组成的有序列表，并用变量来存储数据，用语句来执行指令。
   
   过程式编程（procedural programming）是指引入了过程（procedure）、函数（function）或子程序（subroutine/subprogram）的命令式编程。
   
   结构化编程时过程式编程的一种原则，其主要思想是：提倡在宏观上采用‘自顶向下’的设计，微观上采用顺序、选择和循环的逻辑结构，摒弃或限制`goto`语句，以保证程序结构清晰、易于调试和维护。

6. 命令式编程模拟电脑运算，是行动导向（Action-Oriented）的，关键在于定义解法，即“怎么做”，因而算法是显性而目标是隐性的；声明式编程模拟人脑思维，目标驱动（Goal-Driven）的，关键在于描述问题，即“做什么”，因而目标是显性而算法是隐性的。
   
   + 命令式 → 过程式 → 结构化过程式
   
   + 声明式 → 函数式，数据流式；逻辑式，约束式；属性式；标记式、规范式等
   
   函数式编程：通过数学函数的表达式变换和计算来求值。
   
   逻辑式编程：通过一系列事实和规则，利用数理逻辑来推导或论证结论。

7. 命令式编程的变量代表抽象化的内存，所存内容可能改变；声明式编程的变量代表抽象化的符号，所指对象一般不会改变。
   
   + 声明式编程专注问题的分析与表达，而不是算法实现，不用指明执行顺序，一般没有或极少有副作用，也不存在内存管理问题。大大降低了编程的复杂度，也适合并发计算。
   
   + 函数式语言和逻辑式语言擅长数理逻辑的应用；
   
   + 命令式语言擅长业务逻辑的，尤其是交互式或事件驱动型应用。

8. 编程是寻求一种机制，将指定的输入转化为指定的输出。
   
   + 命令式：自动机机制，通过设计指令完成从初始态到最终态的转变；
   
   + 函数式：数学变换机制，通过设计函数完成从自变量到因变量的计算；
   
   + 逻辑式：逻辑证明机制，通过逻辑推理完成从题设到结论的证明。

9. OOP（Object-Oriented programming）是一种计算机编程模式，它将对象作为问题空间的基本元素，利用对象和对象间的相互作用来设计程序。
   
   + OOP大多是命令式，也有函数式和逻辑式的OO语言。
   
   + OOP的核心思想可以归纳为：以数据为中心组织逻辑，将系统视为相互作用的对象集合，并利用继承与多态来增强可维护性、可扩展性与可重用性。
   
   + 过程式编程以过程为中心，自顶向下，逐步求精。
   
   + 对象式编程以数据为中心，自底向上，逐步合并。
   
   + 过程式程序的世界是君主制，OO程序的世界是民主制。
   
   + 封装使得对象拥有个体身份，继承使对象拥有家庭身份，多态使得对象拥有社会身份。

10. 并法式编程以进程为导向，以任务为中心，以资源共享与竞争为主线。
    
    + 并法式编程有助于提高运行效率、充分利用资源、提高软件的响应能力、改善用户体验、保证公平竞争，同时以进程为单位将系统模块化，更加真实地模拟世界。
    
    + 合理的并发式设计应该做到：软件易于重用、维护和测试；有效地利用资源、优化程序性能；保障进程安全和活性；减少性能损失和复杂度。

11. | 范式  | 体系   | 模块  | 模块关系  |
    | --- | ---- | --- | ----- |
    | 过程式 | 君主体系 | 过程  | 授命与听命 |
    | 函数式 | 数学体系 | 函数  | 替换与合成 |
    | 逻辑式 | 逻辑体系 | 断言  | 归纳与演绎 |
    | 对象式 | 民主体系 | 对象  | 交流与服务 |
    | 并发式 | 生产体系 | 进程  | 竞争与合作 |

12. STL有3要素：算法（algorithms）、容器（container）和迭代器（iterator）
    
    + 算法是一系列切实有效的步骤；
    
    + 容器是数据的集合，可以理解为抽象的数组；
    
    + 迭代器是算法与容器之间的接口，可以理解为抽象的指针或游标。
    
    + 算法串联数据，如脊贯肉；数据实体算法，如肉附脊。

13. 泛型编程能够打破静态语言的数据类型之间的壁垒，在不牺牲效率并却类型安全的情况下，最大限度地提到算法的普适性。
    
    泛型变成不仅能泛化算法中涉及的概念（数据类型），还能泛化行为（函数、方法和运算）。
    
    泛型编程是以算法为导向的，以算法为中心，逐渐将其所涉及的概念内涵模糊化、外延扩大化，并将其所涉及的运算抽象化、一般化，从而提高算法的可重用性。

14. 领域特定语言 DSL
    
    + DSL 一般不会一步到位地编译成机器语言或汇编语言，而是通过现成的编译器生成器（compiler-compiler 或 compiler generator）首先转化为高级语言。这样不仅大大降低了难度，也方便程序的调试。

15. 元编程 Meta-programming
    
    + 元编程是编写、操纵程序的程序。在传统编程中，运算是动态的，但程序本身是静态的；在元编程中，二者都是动态的。
    
    + 元编程能够减少手工编程，突破原语言的语法限制，提升语言的抽象级别与灵活性，从而提高程序员的生产效率。
    
    + 许多开发工具、框架引擎之类的基础软件都有自动生成代码的功能，如许多IDE如Visual Studio、Delphi、Eclipse均能通过向导、拖放控件等方式自动生成源码；Servlet引擎将 JSP转换为Java代码。创造DSL以便高效地处理专门领域业务。自动生成重复代码，动态改变语句、函数、类等。

16. SoC 就是 Separation of Concerns，即关注点分离；DRY就是Don't repeat yourself，即尽量减少重复代码。
    
    不良代码通病：① 结构混乱或代码紊乱、松散；② 代码重复。解决此问题就是要做到——抽象与分离原则。
    
    抽象与分解的原则：单一化、正交化。
    
    每个模块职责明确专一，模块之间独立，即高内聚低耦合（high cohesion & low coupling）。

17. AOP
    
    + 切面 Aspect 描述的是横切关注点（cross-cutting concerns），是与程序纵向主流执行方向横向正交的关注焦点。
    
    + 接入点是附加行为——建议（advice）的执行点，切入点（pointcut）是指切入点（join point）结合。这些接入点共享一段插入代码。切入点与建议组成切面（aspect），是模块化的横切关注点。
    
    + AOP的实现原理：
      
      AOP的实现关键是将advice的代码嵌入到主题程序中，术语称之为编织（weaving）。编织可以分为两种：一种是静态编织，通过修改源码或字节码（bytecode）在编译器（compile-time）、后编译器（post-compile）或加载器（load-time）嵌入代码（元编程、产生式编程实现）；另一种是动态编织，通过代理（proxy）等技术在运行时（run-time）实现嵌入。
    
    + AOP实施的3步：切面分解、切面实现和切面合成。

18. 事件驱动
    
    + 采用警觉式者主动去轮询（polling），行为取决于自身的观察判断，是流程驱动的，符合常规的流程驱动式编程（Flow-Driven Programming）的模式。
    
    + 采用托付式者被动等通知（notification），行为取决于外来的突发事件，是事件驱动的，符合事件驱动式编程（Event-Driven Programming， aka EDP）的模式。
    
    **何为事件？**
    
    事件是已经发生的某种令人关注的事情。在软件中，它一般表现为一个程序的某些信息状态上的变化。
    
    **事件分类：**
    
    内建事件（built-in event）：
    
    + 底层事件（low-level event）或原生事件（native event）
      
      在用户图形界面（GUI）系统中，这类事件由鼠标、键盘等硬件设备出发；
    
    + 语义事件（semantic event）
      
      一般代表用户的行为逻辑，是若干个底层事件的组合。比如鼠标的拖放（drag-and-drop）多表示移动被拖放的对象，由鼠标按下、移动和释放三个底层事件组成。
    
    用户自定义事件（user-defined event）：
    
    + 虚拟事件（virtual event）
    
    + 原有内建事件基础上的包装。
    
    此外，事件还有自然事件（natural event）和合成事件（synthetic event）。
    
    **事件驱动步骤：**
    
    实现事件处理器；注册事件处理器；实现事件循环。
    
    **事件驱动式的特征**：
    
    被动性与异步性。控制反转导致了事件驱动式编程的****被动性passivity**。此外，事件驱动式编程还具有**异步性（asynchrony）** 的特征，这是由于事件的不可预测性和随机性决定的。

19. 回调函数（callback）
    
    + Callback是指能作为参数传递的函数或代码，它允许底层模块调用高层模块，使调用者与被调者从代码上解耦。异步Callback在传入后并不会立即调用，使调用者与被调者从时间上解耦。
    
    + 在C、CPP中函数指针可以实现callback。此外，抽象类（abstract class）、接口（interface）、CPP中的泛型函子（generic functor）和C#中的委托（delegate）都可以实现callback。

20. 控制反转一般通过callback实现，其目的是降低模块之间的依赖性，从而降低模块的耦合度和复杂度。
    
    依赖反转、控制反转和依赖注射是近义词，它们的主题是控制与依赖，目的是解耦，方法是反转，实现一切的关键是抽象接口。
    
    **依赖反转原则**（Dependency-Inversion Principle，aka DIP）与**控制反转**相比更加具体——高层模块不依赖于低层模块，它们都应依赖抽象；抽象不应依赖于细节，细节应该依赖抽象。
    
    依赖注射（Dependency Injection，aka DI）——动态地为一个软件组件提供外部依赖。

21. 软件的可伸缩想（scalability）一般指从容应对工作量增长的能力，常与性能（performance）等指标一起考量。而**控制反转**的主要作用是降低模块之间的依赖性，从而降低模块的耦合度和复杂度，提高软件的可重用性、柔韧性和可扩展性。

22. 独立是异步的前提，耗时是异步的理由。

23. 观察者模式又称为发行/订阅模式，既是事件驱动式的简化，也是事件驱动式的核心思想。MVC架构是观察者模式在架构设计上的一个应用。

24. 函数式编程中，函数是程序的核心，是头等公民，一般没有货很少有副作用，同时没有显示的内存管理。
    
    函数式编程没有副作用（side affect）的好处：
    
    + 没有副作用的函数易于重构、调试和单元测试。
    
    + 代码有效性与函数顺序无关，方便并发处理和优化处理。
    
    没有副作用的函数式是引用透明的（referential transparency），即一个表达式随时可以用它的值来替换，如数学中的函数一样，保证了数学思维的贯彻与运用。
    
    惰性求值是需求驱动的，可以避免不必要的等待和计算。
    
    相比于过程式和OOP，函数式思想过于数学化和抽象化，语言表现力和运行效率也不足。

25. 代码的长度不是衡量软件复杂度的唯一标准。其中，逻辑结构越复杂、越微妙、受需求变化影响越大，软件越难控制和维护。
    
    **算法=逻辑+控制** 。逻辑式编程将算法中的控制部分大都移交给编程语言，开发人员主要关注算法的核心逻辑。这样大大减轻了开发人员的负担，编码也更加简洁，更具有可维护性和可扩展性。
    
    + 区别于过程式和函数式，逻辑式没有明显的输入和输出。
    
    + 逻辑式编程不仅适用于人工智能方面的学术领域，还广泛适用于各种设计知识管理、决策分析等方面的应用领域。

26. 相比于设计模式，编程范式针对问题领域更广泛，提出的思想和方法更为普遍适用、更抽象、更系统。此外， 设计模式重在设计，对语言和工具要求不高，而编程范式要求建立一套抽象机制和方法体系，离不开语言或工具的支持。
    
    + 编程范式的核心价值在于：突破原有编程方式的某些限制，带来新思维和新方法，从而进一步解放程序员的劳动力。

27. 闭包是一种能保存当初创建时环境变量的函数。它通常以匿名方式存在，多用于函数式编程中，能够让代码结构更加清晰简洁。Java中的匿名函数可以看做是OO化的闭包形式。

28. 所谓迭代学习法，是指在具体知识和抽象理论之间进行增量式的循环学习。
    


// todo. 继续整理第五课 语言小谈

